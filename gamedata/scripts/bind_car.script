local opt_key = "kT" --клавиша открывани€ двери.
local opt_sound = true --звук при открытии дверей.

local update_doors --переменна€ дл€ открыти€ дверей.
local snd_open = sound_object([[car\car_door_open]])
local snd_close = sound_object([[car\car_door_close]])

function printf(text)
	news_manager.send_tip(db.actor,text)
	log1("##"..text)
end
-----------------------------------------------------------------------------------
-- car binder
-----------------------------------------------------------------------------------

function bind(obj)
	local new_binder = car_binder(obj)
--	if obj:spawn_ini() and obj:spawn_ini():section_exist("logic") and obj:spawn_ini():line_exist("logic", "no_bind") and obj:spawn_ini():r_bool("logic", "no_bind") == true then
--		bind_physic_object.init(obj)
--		return
--	end
	obj:bind_object(new_binder)
end

------------------------------------------------------------------------------------
class "car_binder" (object_binder)

function car_binder:__init(obj) super(obj)
	self.object = obj
	self.usable = false
	self.ini = obj:get_visual_ini()
	self.fuel = self.ini:r_float("car_definition", "fuel_tank")
	self.box_id = 0
	--дл€ дверей
	if self.ini ~= nil and self.ini:line_exist("car_definition", "opening_doors") and self.ini:r_bool("car_definition", "opening_doors") == true then
		self.has_doors = true
		self.doors_sound = true
		self.left_door_bone = self.ini:r_string("car_definition", "left_door_bone")
		self.right_door_bone = self.ini:r_string("car_definition", "right_door_bone")
		self.seat_dist = self.ini:r_float("car_definition", "seat_dist")
		self.doors_dist = self.ini:r_float("car_definition", "doors_dist")
	end
end

function car_binder:reinit()
	object_binder.reinit(self)
	db.storage[self.object:id()] = { }
	self.st = db.storage[self.object:id()]
	
	self.health=self.object:get_car() and self.object:get_car():GetfHealth()
end

function car_binder:update(delta)
	object_binder.update(self, delta)
	

--чтобы в Ѕ“–е (у которого в конфиге стоит opening_doors=false) работали спидометр и клаксон  
		if self.object:get_holder_owner() and not self.actor_in_car then
			dmx_cars.on_vehicle_input(self.object:id())
			self.actor_in_car = true
		elseif not self.object:get_holder_owner() and self.actor_in_car then
			self.actor_in_car = false
		end

	
	if self.bone_for_invbox == nil then
		if self.ini ~= nil and self.ini:line_exist("car_definition", "bone_for_invbox") then
			self.bone_for_invbox = self.ini:r_string("car_definition", "bone_for_invbox")
		end
	end
	
	if self.bone_for_invbox ~= nil and self.bone_for_invbox ~= "nil" then
		if self.box_id ~= nil and self.box_id ~= 0 then
			if self.upd_box_pos_t == nil then
				self.upd_box_pos_t = 0
			end
			if self.upd_box_pos_t < time_global() then
				self.upd_box_pos_t = time_global() + 200
				local pos = self.object:bone_position(self.bone_for_invbox)
				if self.last_car_pos == nil then
					self.last_car_pos = pos
				end
				--if pos:distance_to(self.last_car_pos) > 0.01 then --вылеты 0.01 0.02 0.03 0.04 0.05 0.06 0.10

				--if pos:distance_to(self.last_car_pos) > 0.2 then --нет вылета у рафа,лады,есть у зеленой нивы

				if pos:distance_to(self.last_car_pos) > 0.5 then -- нет вылета после правки моделей

				--if pos:distance_to(self.last_car_pos) > 1 then -- точно нет вылета
				
					alife():teleport_object(
						nil,
						pos,
						self.object:level_vertex_id(),
						self.object:game_vertex_id(),
						self.box_id
					)
					this.on_car_box_init(0, level.object_by_id(self.box_id))
				end
				self.last_car_pos = pos
			end
		elseif device().precache_frame <= 1 and self.box_id == 0 then
			local sobj = alife():create(
				"inventory_box",
				self.object:bone_position(self.bone_for_invbox),
				self.object:level_vertex_id(),
				self.object:game_vertex_id()
			)
			local tbl = m_net_utils.get_invbox_data(sobj)
			--tbl.oflags = 0xffffff3b
			tbl.visual = "physics\\equipment_cache\\box_bagaznik"
			m_net_utils.set_invbox_data(tbl, sobj)
			--level.map_add_object_spot(sobj.id, "blue_location", "box")
			self.box_id = sobj.id
			local spawn_manager = level.client_spawn_manager()
			spawn_manager:add(sobj.id, 0, this.on_car_box_init)
		end
	end
	
	local distance = self.object:position():distance_to_sqr(db.actor:position())
	--чЄто нигде не работает, придЄтс€ делать здесь
	if not self.loaded then
	
		xr_logic.initialize_obj(self.object, self.st, self.bLoaded, db.actor, modules.stype_item)
	
		--исправление подвешенных машин
		self.object:get_physics_shell():apply_force(0.0001,0.0001,0.0001)
		--загрузка топлива
		self.object:set_fuel(self.fuel)
		
		--при спауне надо захлопнуть двери(теперь двери сохран€ютс€)
		if self.has_doors then
			self.left_door = self.object:get_physics_shell():get_joint_by_bone_name(self.left_door_bone)
			self.right_door = self.object:get_physics_shell():get_joint_by_bone_name(self.right_door_bone)
			
			if self.left_door_open then
				self:open_left_door(true, false)
			else
				self:open_left_door(false, false)
			end
			
			if self.right_door_open then
				self:open_right_door(true, false)
			else
				self:open_right_door(false, false)
			end
			
			self.object:set_nonscript_usable(false)
			self.usable = false
		end
		self.loaded = true
	end
	
	if self.has_doors then
		local a = vector()
		local b = vector()
		self.left_door:get_anchor(a)
		self.right_door:get_anchor(b)
		--открытие/закрытие дверей
		if update_doors and distance < self.doors_dist and not self.actor_in_car then
			if a:distance_to_sqr(db.actor:position()) < b:distance_to_sqr(db.actor:position()) then
				if self.left_door_open then
					self:open_left_door(false, true)
				else
					self:open_left_door(true, true)
				end
			else
				if self.right_door_open then
					self:open_right_door(false, true)
				else
					self:open_right_door(true, true)
				end
			end
		end
		
		----------------------------------------
		local c = vector():set(device().cam_pos:mad(device().cam_dir, 3))
		if self.actor_in_car then
			if (c:distance_to_sqr(a) < c:distance_to_sqr(b) and self.left_door_open) or (c:distance_to_sqr(a) > c:distance_to_sqr(b) and self.right_door_open) then
				if not self.usable_in_car then
					get_console():execute("unbind_console kf")
					self.usable_in_car = true
				end
			else
				if self.usable_in_car then
					get_console():execute("bind_console mm_net_player_name none kf")
					self.usable_in_car = false
				end
			end
			
			if update_doors then
				if c:distance_to_sqr(a) < c:distance_to_sqr(b) then
					if self.left_door_open then
						self:open_left_door(false, true)
					else
						self:open_left_door(true, true)
					end
				else
					if self.right_door_open then
						self:open_right_door(false, true)
					else
						self:open_right_door(true, true)
					end
				end
			end
		else
			if not self.usable_in_car then
				get_console():execute("unbind_console kf")
				self.usable_in_car = true
			end
		end
		----------------------------------------
		if distance < self.doors_dist then
			if (a:distance_to_sqr(db.actor:position()) < self.seat_dist and self.left_door_open) or (b:distance_to_sqr(db.actor:position()) < self.seat_dist and self.right_door_open) then
				if not self.usable then
					self.object:set_nonscript_usable(true)
					self.usable = true
				end
			else
				if self.usable then
					self.object:set_nonscript_usable(false)
					self.usable = false
				end
			end
		end
		--установка tip text
		if (a:distance_to_sqr(db.actor:position()) < self.doors_dist  and not self.left_door_open) or (b:distance_to_sqr(db.actor:position()) < self.doors_dist and not self.right_door_open) then
			self.object:set_tip_text("Open the door (t)")
		else
			self.object:set_tip_text_default()
		end
	end
	update_doors = false
	
	if self.st.active_section ~= nil or (self.object:spawn_ini() ~= nil and self.object:spawn_ini():section_exist("drop_box") == true) then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
		self.object:set_callback(callback.hit, car_binder.hit_callback, self)
		self.object:set_callback(callback.death, car_binder.death_callback, self)
		self.object:set_callback(callback.use_object, car_binder.use_callback, self)
	end
	
	-- дл€ бтра hit_callback не вызываетс€. заткнЄм эту дырку.
	if self.health and (not self.nofixonhit) then
		local health=self.object:get_car() and self.object:get_car():GetfHealth()
		if health then
			if self.health-health>0.00001 then
				-- amk.mylog("health decrease for "..self.object:name())
				self.health=health
				self:hit_callback(self.object, self.health-health, vector():set(1,0,0), db.actor, 0)
				self.nofixonhit=nil
			end
		end
	end
end

function car_binder:use_callback(obj, who)
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "use_callback", obj, who)
	end
end

function car_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	if self.st.ph_on_hit then
		xr_logic.issue_event(self.object, self.st.ph_on_hit, "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
	end
	self.nofixonhit=true
end

function car_binder:death_callback(victim, who)
	if self.st.active_section then
		xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
	end
end

function car_binder:open_left_door(open, snd)
	if open then
		self.left_door:set_max_force_and_velocity(200, -3, 0)
		if opt_sound then snd_open:play_at_pos(self.object, self.object:position()) end
		self.left_door_open = true
	else
		self.left_door:set_max_force_and_velocity(200, 3, 0)
		if opt_sound then snd_close:play_at_pos(self.object, self.object:position()) end
		self.left_door_open = false
	end
end

function car_binder:open_right_door(open, snd)
	if open then
		self.right_door:set_max_force_and_velocity(200, 3, 0)
		if opt_sound and snd then snd_open:play_at_pos(self.object, self.object:position()) end
		self.right_door_open = true
	else
		self.right_door:set_max_force_and_velocity(200, -3, 0)
		if opt_sound and snd then snd_close:play_at_pos(self.object, self.object:position()) end
		self.right_door_open = false
	end
end

function car_binder:net_spawn(sobject)
	if not object_binder.net_spawn(self, sobject) then
		return false
	end
	
	if alife():object(self.object:id()) == nil then
		return false
	end
	return true
end

function car_binder:net_destroy()
	local st = db.storage[self.object:id()]
	db.storage[self.object:id()] = nil
	object_binder.net_destroy(self)
	if st.active_scheme then
		xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
	end
end

function car_binder:net_save_relevant()
	return true
end

function car_binder:save(packet)
	object_binder.save(self, packet)
	xr_logic.save_obj(self.object, packet)
	packet:w_bool(self.left_door_open)
	packet:w_bool(self.right_door_open)
	packet:w_float(self.object:get_fuel())
	packet:w_s16(self.box_id)
end

function car_binder:load(reader)
	object_binder.load(self, reader)
	xr_logic.load_obj(self.object, reader)
	self.left_door_open = reader:r_bool()
	self.right_door_open = reader:r_bool()
	self.fuel = reader:r_float()
	self.box_id = reader:r_s16()
	self.bLoaded = true
end

--ѕереход багажника в онлайн
function on_car_box_init(id, obj)
	if obj == nil then
		return nil
	end
	obj:set_tip_text("Search the rack (F)")
end

function on_actor_update()
	if get_console():get_string("mm_net_player_name") == "active" then
		update_doors = true
		get_console():execute("mm_net_player_name none")
	end
end

function on_actor_net_spawn()
	get_console():execute("bind_console mm_net_player_name active " .. opt_key)
end